module O_Field

   ! Import necessary modules.
   use O_Kinds

   ! Define the module data used by multiple subroutines.
real (kind=double), allocatable, dimension (:,:) :: accumCharge  ! Accumulated
         ! charge for each spin,kPoint combination.
real (kind=double) :: accumChargeKP
   real (kind=double), allocatable, dimension (:,:,:) :: profilePsiReal
   real (kind=double), allocatable, dimension (:,:,:) :: profilePsiImag
   real (kind=double), allocatable, dimension (:,:,:) :: profileWav
   real (kind=double), allocatable, dimension (:,:,:) :: profileRho
   real (kind=double), allocatable, dimension (:,:,:) :: profilePot
         ! Index1=a,b,c
         ! Index2 = As identified in subroutine initEnv.  The important thing
         !          is that in the non spin polarized case the last Index2 is
         !          always the potential while in the spin polarized case the
         !          last two Index2 values are the spin-up and spin-down
         !          potentials.  This is important because they have different
         !          units that the other charge columns.
         ! Index3 = 1..max(numMeshPoints(a,b,c))
   real (kind=double), allocatable, dimension (:,:,:,:) :: meshChunk ! The
         ! Mesh points all collected into a single array. The first index is
         ! for xyz, the remaining three indices are for the abc lattice
         ! vectors.
#ifndef GAMMA
   complex (kind=double), allocatable, dimension (:,:,:) :: &
         & accumWaveFnCoeffsPsiWav
   complex (kind=double), allocatable, dimension (:,:,:,:) :: &
         & accumWaveFnCoeffsRho
   real    (kind=double), allocatable, dimension (:,:) :: &
         & accumWaveFnCoeffsNeut
#else
   real    (kind=double), allocatable, dimension (:,:) :: &
         & accumWaveFnCoeffsPsiWavGamma
   real    (kind=double), allocatable, dimension (:,:,:) :: &
         & accumWaveFnCoeffsRhoGamma
   real    (kind=double), allocatable, dimension (:) :: &
         & accumWaveFnCoeffsNeutGamma
#endif

   ! Linked list used to build contributions to a given mesh point from
   !   each Gaussian type orbital (GTO) of each atom.
   type atomGTOList
      type(atomGTOList), pointer :: next
      integer :: numGTOs
#ifndef GAMMA
      complex (kind=double), allocatable, dimension(:) :: contrib
#else
      real (kind=double), allocatable, dimension(:) :: contribGamma
#endif
   end type atomGTOList
   type (atomGTOList), pointer :: head
   type (atomGTOList), pointer :: curr
   integer(hsize_t) :: totalNumGTOs


   ! Begin listing module subroutines.

contains



subroutine computeFieldMesh(inSCF)

   ! The goal of this subroutine is to evaluate the complex wave function,
   !   the square of the complex wave function, the charge density, and the
   !   fitted potential function along with the same functions minus similar
   !   functions defined for a non-interacting system, and also projections
   !   of all the above functions along the a, b, and c crystal axes as one-
   !   dimensional curves.
   ! The user has the ability to be selective with respect to the energy
   !   ranges included in the olcao.dat file.
   ! The basic algorithm follows:

   ! A real-space mesh is defined according to a request from the user about
   !   the number of points along each of the a,b,c axes in the olcao.dat
   !   input file.
   ! The (complex) wave function is read in from disk. It is a set of column
   !   vectors that represent single particle (or spin degenerate) states.
   !   There is one wave function matrix for each k-point and spin (up, dn).
   !   Each matrix is independently operated on.
   ! The value of the (complex) system wave function at any given mesh point
   !   (i) is equal to the sum of the contributions from all basis functions
   !   from all energy states.
   ! Once we have a numerical representation of the wave function, we can get
   !   the square of the wave function just by squaring the numerical values
   !   at each mesh point.

   ! Import the necessary modules.
   use HDF5
   use O_Kinds
   use O_TimeStamps
   use O_Potential,    only: spin, potCoeffs
   use O_Basis,        only: initializeAtomSite
   use O_Populate,     only: electronPopulation
   use O_Constants,    only: smallThresh, hartree
   use O_PotTypes,     only: maxNumPotAlphas, potTypes
   use O_AtomicSites,  only: valeDim, numAtomSites, atomSites
   use O_Kpoints,      only: numKPoints, kPointWeight, phaseFactor
   use O_Input,        only: numStates, numElectrons, doProfileField, &
         & eminFIELD, emaxFIELD, doPsiFIELD, doWavFIELD, doRhoFIELD, &
         & doPotFIELD, doXDMFField
!   use O_OpenDX,       only: printODXFieldHead, printODXFieldTail, &
!         & printODXAtomPos, printODXLattice
   use O_XDMF_VTK,     only: printXDMFMetaFile
   use O_AtomicTypes,  only: numAtomTypes, atomTypes, maxNumAtomAlphas, &
         & maxNumStates, maxNumValeRadialFns
   use O_Lattice,      only: logBasisFnThresh, numCellsReal, cellSizesReal, &
         & cellDimsReal, numMeshPoints, realVectors, realFractStrideLength, &
         & findLatticeVector, realCellVolume
   use O_FieldHDF5,    only: psiR_did, psiI_did, wav_did, rho_did, pot_did, &
         & mesh_did, triggerAxis, meshTriggerAxis, fieldDimsChunk, &
         & meshDimsChunk, memFieldChunk_dsid, memMeshChunk_dsid, field_dsid, &
         & mesh_dsid, numDataSets
#ifndef GAMMA
   use O_MatrixSubs,      only: readMatrix
   use O_SecularEquation, only: valeVale, energyEigenValues, readDataSCF, &
         & readDataPSCF, valeValeOL
#else
   use O_MatrixSubs,      only: readMatrixGamma
   use O_SecularEquation, only: valeValeGamma, energyEigenValues, &
         & readDataSCF, readDataPSCF, valeValeOLGamma
#endif

   ! Make sure that no variables are accidentally defined.
   implicit none

   ! Define passed parameters.
   integer, intent(in) :: inSCF

   ! Define local variables.
   integer :: hdferr
   integer :: a,b,c
   integer :: i,j,k,l,m,n  ! Loop index variables.
   integer :: dimOne
   integer :: skipKP
   integer :: currentPointCount
   integer :: energyLevelCounter
   integer (hsize_t), dimension (3) :: currentStartIndices
   integer (hsize_t), dimension (4) :: currentMeshStartIndices
   integer, allocatable, dimension(:,:) :: minStateIndex
   integer, allocatable, dimension(:,:) :: maxStateIndex
   real (kind=double) :: cutoff
   real (kind=double) :: shiftedSepSqrd  ! Separation (r) between atom & mesh.
   real (kind=double), dimension(3) :: shiftedVec ! Vector between atom & mesh.
   real (kind=double), dimension(3) :: latticeVector
   real (kind=double), dimension(3) :: shiftedAtomPos
   real (kind=double), allocatable, dimension (:) :: negligLimit
   real (kind=double), allocatable, dimension (:,:,:) :: &
         & structuredElectronPopulation
!#ifndef GAMMA
!   real (kind=double), allocatable, dimension (:,:) :: tempRealValeVale
!   real (kind=double), allocatable, dimension (:,:) :: tempImagValeVale
!#endif


   ! Data for each mesh point.  For spin non-polarized calculations, we have
   !   for the last array dimension: Index1 = Total, Index2 = Neutral, Index3 =
   !   Potential.  For spin polarized calculations we have for the last array
   !   dimension:  Index1 = Spin up, Index2 = spin down, Index3 = Neutral,
   !   Index4 = Neutral.  These values will be appropriately combined to form
   !   the data listed in the initEnv subroutine. (They may not currently be
   !   combined. Seems to be just interacting and just non-interacting, not the
   !   difference.)
   real (kind=double), allocatable, dimension (:,:,:,:) :: dataChunkPsiReal
#ifndef GAMMA
   real (kind=double), allocatable, dimension (:,:,:,:) :: dataChunkPsiImag
#endif
   real (kind=double), allocatable, dimension (:,:,:,:) :: dataChunkWav
   real (kind=double), allocatable, dimension (:,:,:,:) :: dataChunkRho
   real (kind=double), allocatable, dimension (:,:,:,:) :: dataChunkPot
real (kind=double), allocatable, dimension (:,:) :: currNumElec
complex (kind=double), allocatable, dimension (:) :: tempPointValue
#ifndef GAMMA
   complex (kind=double), allocatable, dimension (:,:) :: waveFnEvalPsiWav
   complex (kind=double), allocatable, dimension (:,:,:) :: waveFnEvalRho
   complex (kind=double), dimension(2) :: tempTerm
#else
   real (kind=double), allocatable, dimension (:) :: waveFnEvalPsiWavGamma
   real (kind=double), allocatable, dimension (:,:,:) :: waveFnEvalRhoGamma
   real (kind=double), dimension(2) :: tempTerm
#endif

   ! Atom specific variables that change with each atom loop iteration.
   integer                               :: currB
   integer                               :: currC
   integer                               :: currentCumulAlphaSum
   integer                               :: currentNumPotAlphas
   integer                               :: currentValeStateIndex
   integer                               :: currentMaxValeQN_l
   integer                               :: currentNumValeRadialFns
   integer,              dimension (2)   :: currentAtomType
   integer,              dimension (2)   :: currentElements
   integer,              dimension (2)   :: currentNumAlphas
   integer,              dimension (2)   :: currentNumCoreStates
   integer,              dimension (2)   :: currentNumValeStates
   integer,              dimension (2)   :: currentNumTotalStates
   integer,              dimension (4)   :: currentNumOrbAlphas
   integer, allocatable, dimension (:)   :: currentValeQN_lList
   integer, allocatable, dimension (:,:) :: currentlmIndex
   integer, allocatable, dimension (:,:) :: currentlmAlphaIndex
   real (kind=double) :: aStepSize, bStepSize, cStepSize
   real (kind=double)                    :: atomMeshSepSqrd
   real (kind=double)                    :: maxLatticeRadius
   real (kind=double), dimension (3,2)   :: currentPosition
   real (kind=double), allocatable, dimension (:)      :: currentPotAlphas
   real (kind=double), allocatable, dimension (:,:)    :: currentPotCoeffs
   real (kind=double), allocatable, dimension (:,:)    :: currentAlphas
   real (kind=double), allocatable, dimension (:,:,:)  :: currentBasisFns
#ifndef GAMMA
   complex (kind=double), allocatable, dimension (:,:,:,:) :: &
         & modifiedBasisFnsPsiWav
   complex (kind=double), allocatable, dimension (:,:,:,:,:) :: &
         & modifiedBasisFnsRho
#else
   real (kind=double), allocatable, dimension (:,:,:)  :: &
         & modifiedBasisFnsPsiWavGamma
   real (kind=double), allocatable, dimension (:,:,:,:)  :: &
         & modifiedBasisFnsRhoGamma
#endif

   ! Atom specific variables that will change with each real space cell loop.
   integer                                        :: orbitalCount
   integer                                        :: currentOrbType
   integer                                        :: lastContribAlphaIndex
   integer                                        :: lastContribPotAlphaIndex
   integer                                        :: tempNumAlphas
   real (kind=double)                             :: x,y,z,rSqrd
   real (kind=double), dimension (16)             :: angularFactor
   real (kind=double), allocatable, dimension (:) :: potAlphaDist
   real (kind=double), allocatable, dimension (:) :: alphaDist
   real (kind=double), allocatable, dimension (:) :: expPotAlphaDist
   real (kind=double), allocatable, dimension (:) :: expAlphaDist
#ifndef GAMMA
   complex (kind=double), allocatable, dimension (:,:,:) :: atomicOrbitalPsiWav
   complex (kind=double), allocatable, dimension (:,:,:,:) :: atomicOrbitalRho
#else
   real (kind=double), allocatable, dimension (:,:) :: atomicOrbitalPsiWavGamma
   real (kind=double), allocatable, dimension (:,:,:) :: atomicOrbitalRhoGamma
#endif
!complex (kind=double), allocatable, dimension(:,:) :: identity

   ! Log the beginning of the wave function evaluation.
   call timeStampStart(25)

   ! Initialize the module environment
   call initEnv

   ! Allocate space for locally defined allocatable arrays.

   ! Allocate space to hold records of the state indices to include.
   allocate (minStateIndex(spin,numKPoints))
   allocate (maxStateIndex(spin,numKPoints))

   ! Make the data chunks for each type of field first.
   if (doPsiFIELD == 1) then
      allocate (dataChunkPsiReal(spin+2,fieldDimsChunk(1),fieldDimsChunk(2),&
            & fieldDimsChunk(3)))
#ifndef GAMMA
      allocate (dataChunkPsiImag(spin+2,fieldDimsChunk(1),fieldDimsChunk(2),&
            & fieldDimsChunk(3)))
#endif
   endif

   if (doWavFIELD == 1) then
      allocate (dataChunkWav(spin+2,fieldDimsChunk(1),fieldDimsChunk(2),&
            & fieldDimsChunk(3)))
   endif

   if (doRhoFIELD == 1) then
      allocate (dataChunkRho(spin+2,fieldDimsChunk(1),fieldDimsChunk(2),&
            & fieldDimsChunk(3)))
   endif

   if (doPotFIELD == 1) then
      allocate (dataChunkPot(spin+2,fieldDimsChunk(1),fieldDimsChunk(2),&
            & fieldDimsChunk(3)))
   endif


#ifndef GAMMA
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      allocate (waveFnEvalPsiWav(spin+2,numKPoints))
      allocate (modifiedBasisFnsPsiWav(maxNumAtomAlphas,maxNumStates,&
            & spin+2,numKPoints))
      allocate (atomicOrbitalPsiWav(maxNumStates,spin+2,numKPoints))
   endif
   if (doRhoFIELD == 1) then
      allocate (waveFnEvalRho(numStates,spin+2,numKPoints))
      allocate (modifiedBasisFnsRho(maxNumAtomAlphas,maxNumStates,numStates,&
            & spin+2,numKPoints))
      allocate (atomicOrbitalRho(maxNumStates,numStates,spin+2,numKPoints))
   endif
#else
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      allocate (waveFnEvalPsiWavGamma(spin+2))
      allocate (modifiedBasisFnsPsiWavGamma(maxNumAtomAlphas,maxNumStates,&
            & spin+2))
      allocate (atomicOrbitalPsiWavGamma(maxNumStates,spin+2))
   endif
   if (doRhoFIELD == 1) then
      allocate (waveFnEvalRhoGamma(valeDim,numStates,spin+2))
      allocate (modifiedBasisFnsRhoGamma(maxNumAtomAlphas,maxNumStates,&
            & numStates,spin+2))
      allocate (atomicOrbitalRhoGamma(maxNumStates,numStates,spin+2))
   endif
#endif

   if (doPsiFIELD == 1) then
      allocate (profilePsiReal(3,spin+2,maxVal(numMeshPoints(:))))
#ifndef GAMMA
      allocate (profilePsiImag(3,spin+2,maxVal(numMeshPoints(:))))
#endif
   endif
   if (doWavFIELD == 1) then
      allocate (profileWav(3,spin+2,maxVal(numMeshPoints(:))))
   endif
   if (doRhoFIELD == 1) then
      allocate (profileRho(3,spin+2,maxVal(numMeshPoints(:))))
   endif
   if (doPotFIELD == 1) then
      allocate (profilePot(3,spin+2,maxVal(numMeshPoints(:))))
   endif
   allocate (structuredElectronPopulation (numStates,numKPoints,spin))
allocate (accumCharge(spin,numKPoints))
allocate (tempPointValue(10))
   allocate (currentBasisFns(maxNumAtomAlphas,maxNumStates,2))
   allocate (currentPotCoeffs(maxNumPotAlphas,spin))
   allocate (currentPotAlphas(maxNumPotAlphas))
   allocate (currentAlphas(maxNumAtomAlphas,2))
   allocate (currentlmAlphaIndex(maxNumAtomAlphas,2))
   allocate (currentlmIndex(maxNumStates,2))
   allocate (currentValeQN_lList(maxNumValeRadialFns))
   allocate (potAlphaDist(maxNumPotAlphas))
   allocate (alphaDist(maxNumAtomAlphas))
   allocate (expPotAlphaDist(maxNumPotAlphas))
   allocate (expAlphaDist(maxNumAtomAlphas))

allocate (currNumElec (numKPoints,spin))

!   ! If we will create an OpenDX file, then we will print the header for the
!   !   field data, the lattice information, and the atomic positions now.
!   if (doODXField == 1) then
!!write (20,*) "numActiveDataSets =",numActiveDataSets
!      call printODXFieldHead (numActiveDataSets)
!      call printODXAtomPos
!      call printODXLattice
!   endif

   if (doXDMFField == 1) then
      call printXDMFMetaFile
   endif

   ! Initialize the profile data structure.
   if (doPsiFIELD == 1) then
      profilePsiReal (:,:,:) = 0.0_double
#ifndef GAMMA
      profilePsiImag (:,:,:) = 0.0_double
#endif
   endif
   if (doWavFIELD == 1) then
      profileWav (:,:,:) = 0.0_double
   endif
   if (doRhoFIELD == 1) then
      profileRho (:,:,:) = 0.0_double
   endif
   if (doPotFIELD == 1) then
      profilePot (:,:,:) = 0.0_double
   endif


   ! Fill a matrix of electron populations from the electron population that
   !   was computed in populateLevels. Note that electronPopulation is a one
   !   dimensional array that has some order, but is not sorted in the way
   !   that the energy eigen values were sorted.  Please read the comments in
   !   the populateLevels subroutine to understand the order.
   !   (You can also probably get it from the loop order here ;)
   energyLevelCounter=0
   do i = 1, numKPoints
      do j = 1, spin
         do k = 1, numStates
            energyLevelCounter = energyLevelCounter + 1
            structuredElectronPopulation (k,i,j) = electronPopulation(&
                  & energyLevelCounter)
         enddo
      enddo
   enddo

   ! Define whether the packed arrays have two rows (complex) or one (real).
#ifndef GAMMA
   dimOne = 2
#else
   dimOne = 1
#endif

   ! Determine the range of states to evaluate for each kpoint and spin.
   do i = 1, numKPoints
      do j = 1, spin

         ! Assume that the first state index will be the min state index.
         !   This will be fixed to a higher state if any are found that are
         !   below the requested lowest energy state.
         minStateIndex(j,i) = 1
         do k = 1, numStates
            if (energyEigenValues(k,i,j)*hartree >= eminFIELD) then
               minStateIndex(j,i) = k
               exit
            endif
         enddo

         ! Assume that the last state will be the max state index.  This will
         !   be fixed to a lower state if one is found that exceeds the
         !   requested highest energy state.
         maxStateIndex(j,i) = numStates
         do k = 2, numStates
            if (energyEigenValues(k,i,j)*hartree > emaxFIELD) then
               maxStateIndex(j,i) = k-1
               exit
            endif
         enddo

      enddo
   enddo

minStateIndex(:,:) = 1
maxStateIndex(:,:) = 1

write (20,*) "minStateIndex=",minStateIndex(:,:)
write (20,*) "maxStateIndex=",maxStateIndex(:,:)


   ! Allocate space to read the wave functions and accumulate the coeffs.  Also
   !   initialize the coefficient accumulators. No coeffs needed for total or
   !   (up, down) potential.
#ifndef GAMMA
   allocate (valeVale(valeDim,numStates,spin))
!allocate (valeValeOL(valeDim,valeDim))
!allocate (identity(numStates,numStates))
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      allocate (accumWaveFnCoeffsPsiWav(valeDim,spin+2,numKPoints))
      accumWaveFnCoeffsPsiWav(:,:,:) = cmplx(0.0_double,0.0_double)
   endif
   if (doRhoFIELD == 1) then
      allocate (accumWaveFnCoeffsRho(valeDim,numStates,spin+2,numKPoints))
      accumWaveFnCoeffsRho(:,:,:,:) = cmplx(0.0_double,0.0_double)
   endif
   allocate (accumWaveFnCoeffsNeut(valeDim,numKPoints))
   accumWaveFnCoeffsNeut(:,:) = 0.0_double
#else
   allocate (valeValeGamma(valeDim,numStates,spin))
!allocate (valeValeOLGamma(valeDim,valeDim))
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      allocate (accumWaveFnCoeffsPsiWavGamma(valeDim,spin+2))
      accumWaveFnCoeffsPsiWavGamma(:,:) = 0.0_double
   endif
   if (doRhoFIELD == 1) then
      allocate (accumWaveFnCoeffsRhoGamma(valeDim,numStates,spin+2))
      accumWaveFnCoeffsRhoGamma(:,:,:) = 0.0_double
   endif
   allocate (accumWaveFnCoeffsNeutGamma(valeDim))
   accumWaveFnCoeffsNeutGamma(:) = 0.0_double
#endif


   ! For each atomic type in the system compute the negligability limit. If
   !   the square of the separation between an atomic site and a mesh point is
   !   greater than this computed value then the contribution of this atom is
   !   considered to be negligable. This negligability limit is computed based
   !   on the basis function negligability limit for gaussian integration
   !   which is derived from the olcao.dat input value of the BASISFUNCTION
   !   CUTOFF (typically 0.1e-15). The difference is that this calculation
   !   will use a cutoff that is significantly reduced (0.5 * exponent value)
   !   (typcially 0.1e-7.5).
   allocate (negligLimit(numAtomTypes))  ! Many values may be the same.
   cutoff = logBasisFnThresh/2.0_double
!write (20,*) "cutoff=",cutoff
!call flush (20)
   do i = 1, numAtomTypes
      negligLimit(i) = cutoff / atomTypes(i)%alphas(1)
!write (20,*) "negligLimit(i),i=",negligLimit(i),i
!call flush (20)
   enddo

   ! Save special coefficients to represent the neutral non-interacting
   !   electronic distribution for each atom.
   call makeNeutralCoeffs

accumCharge(:,:) = 0.0_double
accumChargeKP = 0.0_double
   do i = 1, numKPoints

      ! Skip any kpoints with a negligable contribution for each state.
      skipKP = 0
      do j = 1, numStates
         if (sum(abs(structuredElectronPopulation(j,i,:)))>smallThresh) then
            skipKP = 1
            exit
         endif
      enddo
      if (skipKP == 0) then
         cycle
      endif

      ! Read the computed wave function into the valeVale matrix.
      do j = 1, spin
         if (inSCF == 1) then
            call readDataSCF(j,i,numStates,0) ! 0 = Read wave functions only.
         else
            call readDataPSCF(j,i,numStates,0) ! 0 = Read wave functions only.
         endif
      enddo

      ! Accumulate the wave function coefficients including either the kpoint
      !   weight factor or the charge occupancy weight factor depending on the
      !   value of doRho.
      do j = 1, spin

currNumElec(i,j) = sum(structuredElectronPopulation(&
      & minStateIndex(j,i):maxStateIndex(j,i),i,j))
write (20,*) "i,j,currNumElec(i,j) = ",i,j,currNumElec(i,j)
!write (20,*) "minStateIndex=",minStateIndex
!write (20,*) "maxStateIndex=",maxStateIndex

         ! Accumulate the wave function coefficients from every energy state
         !   into a single vector. Note that the kPointWeight or electron
         !   population needs to be square-rooted because this quantity
         !   will be squared later on.
#ifndef GAMMA
!identity(:,:) = cmplx(0.0d0,0.0d0)
!identity = matmul(transpose(conjg(valeVale(:,:numStates,j))), &
!      & matmul(valeValeOL(:,:),valeVale(:,:numStates,j)))
!do l = 1, numStates
!write (20,*) identity(:,l)
!enddo
!accumCharge(j,i) = 0.0_double

!minStateIndex = 1
!maxStateIndex = 4
!write(20,*) "min,max=",minStateIndex,maxStateIndex
         do k = minStateIndex(j,i), maxStateIndex(j,i)

!tempPointValue(:)=cmplx(0.0_double,0.0_double)
!do l = 1, valeDim
!do m = 1, valeDim
!tempPointValue(1) = tempPointValue(1) + &
!   & conjg(valeVale(l,k,j))*valeVale(l,k,j)
!enddo
!enddo
!write (20,*) "k,valeVale state squared=",k,tempPointValue(1)

            ! Accumulate the wave function coefficients
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
               accumWaveFnCoeffsPsiWav(:,j,i) = &
                     & accumWaveFnCoeffsPsiWav(:,j,i) + &
                     & sqrt(kPointWeight(i)/real(spin,double)) * &
                     & valeVale(:,k,j)
!!write (20,*) "kPointWeight(i),spin=",kPointWeight(i),spin
!!call flush (20)
            endif

            if (doRhoFIELD == 1) then
               accumWaveFnCoeffsRho(:,k,j,i) = &
                     & accumWaveFnCoeffsRho(:,k,j,i) + &
                     & sqrt(structuredElectronPopulation(k,i,j)) * &
                     & valeVale(:,k,j)
accumCharge(j,i) = accumCharge(j,i) + structuredElectronPopulation(k,i,j)
!write(20,*) "dot",dot_product(accumWaveFnCoeffsRho(:,j,i),&
!                  & accumWaveFnCoeffsRho(:,j,i))
!write(20,*) "sqrt dot",sqrt(dot_product(accumWaveFnCoeffsRho(:,j,i),&
!                  & accumWaveFnCoeffsRho(:,j,i)))
!            accumWaveFnCoeffsRho(:,j,i) = accumWaveFnCoeffsRho(:,j,i) / &
!                  & sqrt(dot_product(accumWaveFnCoeffsRho(:,j,i),&
!                  & accumWaveFnCoeffsRho(:,j,i)))
write (20,*) "k,i,j structEPop(k,i,j)=",&
 & k,i,j,structuredElectronPopulation(k,i,j)
call flush (20)
            endif

!!write (20,*) "before aWFC=",accumWaveFnCoeffs(:,j,i)
!!write (20,*) "vV=",valeVale(:,k,j)
         enddo ! k min->max state

!         ! Remove cross terms.
!         do k = minStateIndex, maxStateIndex
!            do l = k+1, maxStateIndex
!write(20,*) "cross ", 2.0_double * valeVale(:,k,j) * valeVale(:,l,j)
!               accumWaveFnCoeffsRho(:,j,i) = accumWaveFnCoeffsRho(:,j,i) - &
!                     & 2.0_double * valeVale(:,k,j) * valeVale(:,l,j)
!            enddo
!         enddo
write (20,*) "accumCharge=",accumCharge(j,i)
accumChargeKP = accumChargeKP + accumCharge(j,i)
!write (20,*) "before divide aWFC=",accumWaveFnCoeffs(:,j,i)
!tempPointValue(1)=cmplx(0.0_double,0.0_double)
!do k = 1, valeDim
!!do l = 1, valeDim
!tempPointValue(1) = tempPointValue(1) + &
!   & conjg(accumWaveFnCoeffs(k,j,i))*accumWaveFnCoeffs(k,j,i)
!!enddo
!enddo
!write (20,*) "accum state squared=",tempPointValue(1)

!         ! The accumulated wave function coefficients across all energy levels
!         !   (for this spin (j) and k-point (i)) need to be normalized if we
!         !   want to look at the charge density. Why? FIX?
!         if (doRhoFIELD == 1) then
!            accumWaveFnCoeffs(:,j,i) = accumWaveFnCoeffs(:,j,i) / &
!                  & sqrt(dot_product(accumWaveFnCoeffs(:,j,i),&
!                  & accumWaveFnCoeffs(:,j,i)))
!         endif
!currNumElec(i,j) = sqrt(dot_product(accumWaveFnCoeffs(:,j,i),&
!& accumWaveFnCoeffs(:,j,i)))

!write (20,*) "after divide aWFC=",accumWaveFnCoeffs(:,j,i)
!tempPointValue(1)=cmplx(0.0_double,0.0_double)
!do k = 1, valeDim
!!do l = 1, valeDim
!tempPointValue(1) = tempPointValue(1) + &
!   & conjg(accumWaveFnCoeffs(k,j,i))*accumWaveFnCoeffs(k,j,i)
!!enddo
!enddo
!write (20,*) "accum state squared after divide=",tempPointValue(1)
#else
         do k = minStateIndex(j,i), maxStateIndex(j,i)
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
               accumWaveFnCoeffsPsiWavGamma(:,j) = &
                     & accumWaveFnCoeffsPsiWavGamma(:,j) + &
                     & sqrt(kPointWeight(i)/real(spin,double)) * &
                     & valeValeGamma(:,k,j)
                  ! FIX, pull kPointWeight mult out of k,j loop.
            endif

            if (doRhoFIELD == 1) then
               accumWaveFnCoeffsRhoGamma(:,k,j) = &
                     & accumWaveFnCoeffsRhoGamma(:,k,j) + &
                     & sqrt(structuredElectronPopulation(k,i,j)) * &
                     & valeValeGamma(:,k,j)
accumCharge(j,i) = accumCharge(j,i) + structuredElectronPopulation(k,i,j)
write (20,*) "k,i,j structEPop(k,i,j)=",&
 & k,i,j,structuredElectronPopulation(k,i,j)
call flush (20)
            endif
         enddo ! k: state

         ! For some reason we don't do the normalization here? I think it
         !   should be done here if it was done there. Or it should not be
         !   done at all.
#endif
      enddo ! j: spin

#ifndef GAMMA
      if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
         if (spin == 1) then
            accumWaveFnCoeffsPsiWav(:,2,i) = &
                  & accumWaveFnCoeffsPsiWav(:,1,i) - &
                  & accumWaveFnCoeffsNeut(:,i)
            accumWaveFnCoeffsPsiWav(:,3,i) = &
                  & accumWaveFnCoeffsNeut(:,i)
         else
            accumWaveFnCoeffsPsiWav(:,3,i) = &
                  & accumWaveFnCoeffsPsiWav(:,1,i) + &
                  & accumWaveFnCoeffsPsiWav(:,2,i) - &
                  & accumWaveFnCoeffsNeut(:,i)
            accumWaveFnCoeffsPsiWav(:,4,i) = &
                  & accumWaveFnCoeffsNeut(:,i)
         endif
      endif
      if (doRhoFIELD == 1) then
         if (spin == 1) then
            do j = minStateIndex(1,i), maxStateIndex(1,i)
               accumWaveFnCoeffsRho(:,j,2,i) = &
                     & accumWaveFnCoeffsRho(:,j,1,i) - &
                     & accumWaveFnCoeffsNeut(:,i)
               accumWaveFnCoeffsRho(:,j,3,i) = accumWaveFnCoeffsNeut(:,i)
            enddo
         else
            do j = minStateIndex(1,i), maxStateIndex(1,i)
               accumWaveFnCoeffsRho(:,j,3,i) = &
                     & accumWaveFnCoeffsRho(:,j,1,i) + &
                     & accumWaveFnCoeffsRho(:,j,2,i) - &
                     & accumWaveFnCoeffsNeut(:,i)
               accumWaveFnCoeffsRho(:,j,4,i) = accumWaveFnCoeffsNeut(:,i)
            enddo
         endif
      endif
#else
      if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
         if (spin == 1) then
            accumWaveFnCoeffsPsiWavGamma(:,2) = &
                  & accumWaveFnCoeffsPsiWavGamma(:,1) - &
                  & accumWaveFnCoeffsNeutGamma(:)
            accumWaveFnCoeffsPsiWavGamma(:,3) = &
                  & accumWaveFnCoeffsNeutGamma(:)
         else
            accumWaveFnCoeffsPsiWavGamma(:,3) = &
                  & accumWaveFnCoeffsPsiWavGamma(:,1) + &
                  & accumWaveFnCoeffsPsiWavGamma(:,2) - &
                  & accumWaveFnCoeffsNeutGamma(:)
            accumWaveFnCoeffsPsiWavGamma(:,4) = &
                  & accumWaveFnCoeffsNeutGamma(:)
         endif
      endif
      if (doRhoFIELD == 1) then
         if (spin == 1) then
            do j = minStateIndex(1,i), maxStateIndex(1,i)
               accumWaveFnCoeffsRhoGamma(:,j,2) = &
                     & accumWaveFnCoeffsRhoGamma(:,j,1) - &
                     & accumWaveFnCoeffsNeutGamma(:)
               accumWaveFnCoeffsRhoGamma(:,j,3) = &
                     & accumWaveFnCoeffsNeutGamma(:)
            enddo
         else
            do j = minStateIndex(1,i), maxStateIndex(1,i) ! FIX for spin
               accumWaveFnCoeffsRhoGamma(:,j,3) = &
                     & accumWaveFnCoeffsRhoGamma(:,j,1) + &
                     & accumWaveFnCoeffsRhoGamma(:,j,2) - &
                     & accumWaveFnCoeffsNeutGamma(:)
               accumWaveFnCoeffsRhoGamma(:,j,4) = &
                     & accumWaveFnCoeffsNeutGamma(:)
            enddo
         endif
      endif
#endif
   enddo ! i kpoint

!write (20,*) "accumChargeKP=",accumChargeKP

   ! There is a lot of calculation that needs to be done here.  We need to
   !   consider each mesh point in turn.  We calculate the accumulated
   !   contributions of each atomic orbital from each atom of each
   !   replicated cell in periodic space.

   ! The orbital contributions depend on the relative x,y,z location of the
   !   mesh point to the atomic site as well as r (the magnitude of the
   !   separation distance).  Recall that the orbitals have an angular
   !   component applied to them from the spherical harmonics.

   ! Initialize the count of the number of mesh points computed.
   currentPointCount = 0

   ! Initialize the data chunk that will hold each of the resultant data types.
   if (doPsiFIELD == 1) then
      dataChunkPsiReal(:,:,:,:) = 0.0_double
#ifndef GAMMA
      dataChunkPsiImag(:,:,:,:) = 0.0_double
#endif
   endif
   if (doWavFIELD == 1) then
      dataChunkWav(:,:,:,:) = 0.0_double
   endif
   if (doRhoFIELD == 1) then
      dataChunkRho(:,:,:,:) = 0.0_double
   endif
   if (doPotFIELD == 1) then
      dataChunkPot(:,:,:,:) = 0.0_double
   endif

   ! Define the initial points of the hyperslab if XDMF HDF5 output is needed.
   if (doXDMFField == 1) then
      currentStartIndices(:) = 0
   endif

   ! Start triple loop on mesh points for evaluating functions. Because the
   !   dataChunk only holds a portion of the whole of each data set, we need
   !   to use memory index variables (currB, currC, a) to index dataChunk.
   ! Each data kind (psi, wav, rho, etc) of the dataChunk will eventually be
   !   put into the correct part of its respective whole data set in the
   !   on-disk file.
   do c = 1, numMeshPoints(3)
      if (triggerAxis < 3) then
         currC = 1
      else
         currC = c
      endif
   do b = 1, numMeshPoints(2)
      if (triggerAxis < 2) then
         currB = 1
      else
         currB = b
      endif
   do a = 1, numMeshPoints(1) ! a is always a valid memory index.
!write (20,*) "a,b,c=",a,b,c
!call flush (20)

      ! Initialize the evaluation of the wave function on this mesh point.
      if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
#ifndef GAMMA
         waveFnEvalPsiWav(:,:) = cmplx(0.0_double,0.0_double)
#else
         waveFnEvalPsiWavGamma(:) = 0.0_double
#endif
      endif
      if (doRhoFIELD == 1) then
#ifndef GAMMA
         waveFnEvalRho(:,:,:) = cmplx(0.0_double,0.0_double)
#else
         waveFnEvalRhoGamma(:,:,:) = 0.0_double
#endif
      endif


      ! Increment the counter of the number of mesh points computed so far.
      currentPointCount = currentPointCount + 1

      ! Compute the location in x,y,z coordinates of the current mesh point by
      !   multiplying the number of fractional strides taken by the lattice
      !   parameters.
      do i = 1, 3
         currentPosition(i,1) = &
               & ((a-1)*realFractStrideLength(1)) * realVectors(i,1) + &
               & ((b-1)*realFractStrideLength(2)) * realVectors(i,2) + &
               & ((c-1)*realFractStrideLength(3)) * realVectors(i,3)
      enddo
!write (20,*) "currentMeshPos=",currentPosition(:,1)
!call flush (20)

      ! Initiate a loop over the number of atoms that will contribute to the
      !   waveFnSqrd at the current mesh point defined by a,b,c loop indices.
      do i = 1, numAtomSites

         ! Obtain key information about this atom. (The use of "2" is
         !   arbitrary.)
         call initializeAtomSite(i,2,currentAtomType,currentElements,&
            & currentNumTotalStates,currentNumCoreStates,currentNumValeStates,&
            & currentNumAlphas,currentlmIndex,currentlmAlphaIndex,&
            & currentPosition,currentAlphas,currentBasisFns)
!write (20,*) "Starting atom site i=",i
!write (20,*) "currentAtomPos=",currentPosition(:,2)
!call flush (20)

         ! Obtain further key information about this atom.
         currentNumValeRadialFns = &
               atomTypes(currentAtomType(2))%numValeRadialFns
         currentValeStateIndex = atomSites(i)%cumulValeStates
         currentMaxValeQN_l = atomTypes(currentAtomType(2))%maxValeQN_l
         currentValeQN_lList(1:currentNumValeRadialFns) = atomTypes(&
               & currentAtomType(2))%valeQN_lList(1:currentNumValeRadialFns)
         currentNumOrbAlphas(:) = &
               & atomTypes(currentAtomType(2))%numOrbAlphas(:)

         ! Obtain information about this potential site.  Carefully note that
         !   I assumed the current atom type = the current pot type.  Bad. Bad.
         currentCumulAlphaSum = potTypes(currentAtomType(2))%cumulAlphaSum
         currentNumPotAlphas = potTypes(currentAtomType(2))%numAlphas
         currentPotAlphas(1:currentNumPotAlphas) = &
               & potTypes(currentAtomType(2))%alphas(1:currentNumPotAlphas)
         do j = 1, spin
            currentPotCoeffs(1:currentNumPotAlphas,j) = &
                  & potCoeffs(currentCumulAlphaSum+1:&
                  & currentCumulAlphaSum+currentNumPotAlphas,j)
         enddo

         ! Find the lattice point closest to the difference between the atom
         !   site and the mesh point site.
         call findLatticeVector((currentPosition(:,1)-currentPosition(:,2)),&
               & latticeVector)

         ! Determine the square of the minimum separation between the mesh
         !   point and the atomic site.
         atomMeshSepSqrd = sum((currentPosition(:,1) - currentPosition(:,2) - &
               & latticeVector(:))**2)

!write (20,*) "atomMeshSepSqrd,negligLimit=",atomMeshSepSqrd, &
!& negligLimit(currentAtomType(2))
!call flush (20)

         ! Compare the current separation to the maximum separation for this
         !   atomic type for the contribution to be considered non-negligable.
         if (atomMeshSepSqrd > negligLimit(currentAtomType(2))) cycle

         ! At this point we know that at least one atom from the set of
         !   lattice replicated atoms will contribute (possibly the atom in the
         !   original cell, but not necessarily).  We will now multiply the
         !   basis function coefficients for this atom by the accumulated wave
         !   function coefficients.
#ifndef GAMMA
         if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
            do j = 1,numKPoints
               do k = 1,spin+2
                  do l = 1,currentNumValeStates(2)
                     modifiedBasisFnsPsiWav(1:currentNumAlphas(2),l,k,j) = &
                           & currentBasisFns(1:currentNumAlphas(2),l,2) * &
                           & accumWaveFnCoeffsPsiWav( &
                           & currentValeStateIndex+l,k,j)
                  enddo
               enddo
            enddo
         endif
         if (doRhoFIELD == 1) then
            do j = 1,numKPoints
               do k = 1,spin+2
                  do l = minStateIndex(1,j), maxStateIndex(1,j)
                     do m = 1,currentNumValeStates(2)
                        modifiedBasisFnsRho(1:currentNumAlphas(2),m,l,k,j) = &
                              & currentBasisFns(1:currentNumAlphas(2),m,2) * &
                              & accumWaveFnCoeffsRho(&
                              & currentValeStateIndex+m,l,k,j)
                     enddo
                  enddo
               enddo
            enddo
         endif
#else
         if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
            do k = 1,spin+2
               do l = 1,currentNumValeStates(2)
                  modifiedBasisFnsPsiWavGamma(1:currentNumAlphas(2),l,k) = &
                        & currentBasisFns(1:currentNumAlphas(2),l,2) * &
                        & accumWaveFnCoeffsPsiWavGamma( &
                        & currentValeStateIndex+l,k)
               enddo
            enddo
         endif
         if (doRhoFIELD == 1) then
            do k = 1,spin+2
               do l = minStateIndex(1,1), maxStateIndex(1,1)
                  do m = 1,currentNumValeStates(2)
                     modifiedBasisFnsRhoGamma(1:currentNumAlphas(2),m,l,k) = &
                           & currentBasisFns(1:currentNumAlphas(2),m,2) * &
                           & accumWaveFnCoeffsRhoGamma(&
                           & currentValeStateIndex+m,l,k)
                  enddo
               enddo
            enddo
         endif
#endif

         ! Determine the maximum radius beyond which no lattice point will be
         !   considered to contribute to the wave function evaluation for this
         !   atom-mesh point pair.  (This is the law of cosines 
         !   c^2 = a^2 + b^2 + 2ab*cos(g) with g = gamma = angle between a and
         !   b.  Here atomMeshSepSqrd = a^2,negligLimit = b^2,g=0.)
         maxLatticeRadius = atomMeshSepSqrd + negligLimit(currentAtomType(2))+&
               & 2.0_double * sqrt(atomMeshSepSqrd * &
               & negligLimit(currentAtomType(2)))

         ! The maxLatticeRadius will always be smaller than the one used for
         !   integration so we don't bother checking to see if we have enough
         !   lattice points to complete the calculation.

         ! Initiate a loop over the number of replicated real space cells.
         do j = 1, numCellsReal

            ! Exit the loop when we have exceeded the necessary number of
            !   lattice points based on distance.
!write (20,*) "j,cellSizesReal(j),maxLatticeRadius",j,cellSizesReal(j),&
!& maxLatticeRadius
!call flush (20)
            if (cellSizesReal(j) > maxLatticeRadius) exit

            ! Obtain the position of the atom shifted by the current lattice.
            shiftedAtomPos(:) = currentPosition(:,2) + latticeVector(:) + &
                  & cellDimsReal(:,j)

            ! Obtain the relative separation x,y,z vector.  This is the vector
            !   between the atomic site in some periodic cell and the mesh
            !   point in the origin cell.
            shiftedVec(:) =  shiftedAtomPos(:) - currentPosition(:,1)

            ! Obtain the squared seperation magnitude between the mesh point
            !   and the shifted position of the atom.
            shiftedSepSqrd = dot_product(shiftedVec(:),shiftedVec(:))

!write (20,*) "j,cellSizesReal(j),shiftedSepSqrd,negligLimit",&
!& j,cellSizesReal(j),shiftedSepSqrd,negligLimit(currentAtomType(2))
!call flush (20)

            ! Determine if this shifted atom position puts it outside of the
            !   above determined negligability limit for this atom pair.
            if (shiftedSepSqrd > negligLimit(currentAtomType(2))) cycle

            ! Now we start a loop over the alphas of this atom.  For each alpha
            !   the "alpha dist." is tested against the negligability distance.
            !   Once an alpha is found that has negligable contribution we can
            !   stop and we only need to consider the alphas up to that point.
            ! Note that alphaDist(k) is initially computed as alpha*r^2 and
            !   cutoff is calculated above as -log(threshold).  So, if the
            !   alphaDist(k) is *greater* than the cutoff, that means that
            !   the contribution is *less* than the minimum necessary to be
            !   non-negligable.  (Tricky!)
            ! Assume that the last alpha will be the last alpha to contribute.
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1) .or. &
                  & (doRhoFIELD == 1)) then
               lastContribAlphaIndex = currentNumAlphas(2)
               do k = 1, currentNumAlphas(2)
                  alphaDist(k) = currentAlphas(k,2)*shiftedSepSqrd
!write (20,*) "alphaDist(k),k,cutoff,currentAlphas(k,2)=",alphaDist(k),k,&
!& cutoff,currentAlphas(k,2)
!call flush(20)
                  if (alphaDist(k) > cutoff) then
                     lastContribAlphaIndex = k
                     exit
                  endif
               enddo

               ! Compute the exponential for each of the alphas needed.  This
               !   will complete all the distance sensitive parts of the
               !   calculation. The rest is simply applying the appropriate
               !   coefficients and angular factors to evaulate the
               !   contribution of each type of orbital (e.g. s,px,py,pz,...).
               expAlphaDist(1:lastContribAlphaIndex) = &
                     & exp(-alphaDist(1:lastContribAlphaIndex))
            endif
!write (20,*) "lastContribAlphaIndex=",lastContribAlphaIndex
!call flush (20)

            if (doPotFIELD == 1) then
               lastContribPotAlphaIndex = currentNumPotAlphas
               do k = 1, currentNumPotAlphas
                  potAlphaDist(k) = currentPotAlphas(k)*shiftedSepSqrd

                  if (potAlphaDist(k) > cutoff) then
                     lastContribPotAlphaIndex = k
                     exit
                  endif
               enddo

               ! Compute the exponential for each potential alpha needed. As
               !   above, this will complete all the distance sensitive parts
               !   of the calculation. Potential Gaussians are all s-type.
               expPotAlphaDist(1:lastContribPotAlphaIndex) = &
                     & exp(-potAlphaDist(1:lastContribPotAlphaIndex))
            endif
!write (20,*) "expAlphaDist(1),currentAlphas(1,2)=",&
!&expAlphaDist(1),currentAlphas(1,2)
!call flush (20)

            ! Note that the general expression for a Gaussian type orbital
            !   (GTO) is A * r^l * exp(-ar^2).  In OLCAO an atomic orbital is
            !   defined as a sum of N GTOs * Ylm(theta,phi).  Each of the GTOs
            !   has a different A and a (alpha) labeled Ai, and ai.  When
            !   expressed in cartesian coordinates the Ylm spherical harmonics
            !   have a 1/r^l term that will cancel the r^l term in the GTO.
            !   The coefficients (Ai) stored in the currentBasisFns(:,:,2)
            !   array for the current atom are actually the product of the
            !   regular GTO coefficients and the Ylm angular normalization
            !   coefficients.

            ! Compute the angular factors for all the necessary orbital types.
            !   Note that the order of the angular factors computed here must
            !   match the order of the coefficients computation in the
            !   renormalizeBasis subroutine in the basis.f90 file.
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1) .or. &
                  & (doRhoFIELD == 1)) then
               angularFactor(1) = 1.0_double
               if (currentMaxValeQN_l > 0) then
                  x=shiftedVec(1)
                  y=shiftedVec(2)
                  z=shiftedVec(3)

                  angularFactor(2) = x
                  angularFactor(3) = y
                  angularFactor(4) = z
                  if (currentMaxValeQN_l > 1) then
                     rSqrd = x*x + y*y + z*z

                     angularFactor(5) = x*y
                     angularFactor(6) = x*z
                     angularFactor(7) = y*z
                     angularFactor(8) = x**2 - y**2
                     angularFactor(9) = 3.0_double*z**2 - rSqrd
                     if (currentMaxValeQN_l > 2) then
                        angularFactor(10) = x*y*z
                        angularFactor(11) = z*(x**2 - y**2)
                        angularFactor(12) = x*(x**2 - 3.0_double*y**2)
                        angularFactor(13) = y*(y**2 - 3.0_double*x**2)
                        angularFactor(14) = z*(5.0_double*z**2 - &
                              & 3.0_double*rSqrd)
                        angularFactor(15) = x*(5.0_double*z**2 - rSqrd)
                        angularFactor(16) = y*(5.0_double*z**2 - rSqrd)
                     endif
                  endif
               endif

               do x = 1, numKPoints
                  do y = 1, spin+2
                     do z = minStateIndex(1,x), maxStateIndex(1,x)

                     ! For each orbital of this atom, at this position,
                     !   accumulate the Gaussian coefficients of the
                     !   contributing alphas.
                     orbitalCount=0
                     do k = 1, currentNumValeRadialFns

                        ! Get the current orbital type (l quantum number)
                        currentOrbType = currentValeQN_lList(k)

                        ! Get a temporary number of alphas needed for the
                        !   present k indexed valence radial function
                        !   (derived from the QN_l of the radial function).
                        tempNumAlphas = currentNumOrbAlphas(currentOrbType + 1)

                        ! Use all the alphas for this radial function or only
                        !   up to the last contributing one.
                        tempNumAlphas = min(lastContribAlphaIndex,&
                              & tempNumAlphas)

                        ! Loop over the possible QN_m values for the current
                        !   QN_l type of orbital.
                        do l = 1, 2 * currentOrbType + 1

                           ! Increment the orbital counter to the next state.
                           orbitalCount = orbitalCount + 1

                           ! Accumulate the product of the Gaussian coefficients
                           !   for this atomic orbital with the contributing
                           !   exponential factors (computed above).  This
                           !   accumulation will be the atomic orbital radial
                           !   function evaluated at the current mesh point for
                           !   each kpoint.
                           ! Then, multiply the atomic orbital radial function
                           !   by the appropriate angular coefficient to make
                           !   the actual atomic orbital evaluated at the
                           !   current mesh point.
#ifndef GAMMA
                           if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
                              atomicOrbitalPsiWav(orbitalCount,y,x) = sum( &
                                    & modifiedBasisFnsPsiWav(1:tempNumAlphas, &
                                    & orbitalCount,y,x) * &
                                    & expAlphaDist(1:tempNumAlphas)) * &
                                    & abs(angularFactor(currentlmIndex( &
                                    & orbitalCount,2)))
                           endif
                           if (doRhoFIELD == 1) then
                              atomicOrbitalRho(orbitalCount,z,y,x) = sum( &
                                    & modifiedBasisFnsRho(1:tempNumAlphas, &
                                    & orbitalCount,z,y,x) * &
                                    & expAlphaDist(1:tempNumAlphas)) * &
                                    & abs(angularFactor(currentlmIndex( &
                                    & orbitalCount,2)))
                           endif
#else
                           if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
                              atomicOrbitalPsiWavGamma(orbitalCount,y) = sum( &
                                    & modifiedBasisFnsPsiWavGamma( &
                                    & 1:tempNumAlphas,orbitalCount,y) * &
                                    & expAlphaDist(1:tempNumAlphas)) * &
                                    & abs(angularFactor(currentlmIndex( &
                                    & orbitalCount,2)))
                           endif
                           if (doRhoFIELD == 1) then
                              atomicOrbitalRhoGamma(orbitalCount,z,y) = sum( &
                                    & modifiedBasisFnsRhoGamma( &
                                    & 1:tempNumAlphas,orbitalCount,z,y) * &
                                    & expAlphaDist(1:tempNumAlphas)) * &
                                    & abs(angularFactor(currentlmIndex( &
                                    & orbitalCount,2)))
                           endif
#endif
                        enddo ! l: m_QN
                     enddo ! k: num vale radial fns (no m_QN)
                     enddo ! z: numStates
                  enddo ! y: spin
               enddo ! x : kpoints

!               ! For each orbital of this atom, at this position, accumulate
!               !   the Gaussian coefficients of the contributing alphas.
!               orbitalCount=0
!               do k = 1, currentNumValeRadialFns
!
!                  ! Get the current orbital type (l quantum number)
!                  currentOrbType = currentValeQN_lList(k)
!
!                  ! Get a temporary number of alphas needed for the present k
!                  !   indexed valence radial function (derived from the QN_l of
!                  !   the radial function).
!                  tempNumAlphas = currentNumOrbAlphas(currentOrbType + 1)
!
!                  ! Use all the alphas for this radial function or only up to
!                  !   the last contributing one.
!                  tempNumAlphas = min(lastContribAlphaIndex,tempNumAlphas)
!
!                  ! Loop over the possible QN_m values for the current QN_l
!                  !   type of orbital.
!                  do l = 1, 2 * currentOrbType + 1
!
!                     ! Increment the orbital counter to the next state.
!                     orbitalCount = orbitalCount + 1
!
!                     do m = 1, numKPoints
!
!                        do n = 1, spin+2
!
!                           ! Accumulate the product of the Gaussian coefficients
!                           !   for this atomic orbital with the contributing
!                           !   exponential factors (computed above).  This
!                           !   accumulation will be the atomic orbital radial
!                           !   function evaluated at the current mesh point for
!                           !   each kpoint.
!                           ! Then, multiply the atomic orbital radial function
!                           !   by the appropriate angular coefficient to make
!                           !   the actual atomic orbital evaluated at the
!                           !   current mesh point.
!#ifndef GAMMA
!                           if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
!                              atomicOrbitalPsiWav(orbitalCount,n,m) = sum( &
!                                    & modifiedBasisFnsPsiWav(1:tempNumAlphas, &
!                                    & orbitalCount,n,m) * &
!                                    & expAlphaDist(1:tempNumAlphas)) * &
!                                    & abs(angularFactor(currentlmIndex( &
!                                    & orbitalCount,2)))
!                           endif
!                           if (doRhoFIELD == 1) then
!                              atomicOrbitalRho(orbitalCount,n,m) = sum( &
!                                    & modifiedBasisFnsRho(1:tempNumAlphas, &
!                                    & orbitalCount,n,m) * &
!                                    & expAlphaDist(1:tempNumAlphas)) * &
!                                    & abs(angularFactor(currentlmIndex( &
!                                    & orbitalCount,2)))
!                           endif
!#else
!                           if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
!                              atomicOrbitalPsiWavGamma(orbitalCount,n) = sum( &
!                                    & modifiedBasisFnsPsiWavGamma( &
!                                    & 1:tempNumAlphas,orbitalCount,n) * &
!                                    & expAlphaDist(1:tempNumAlphas)) * &
!                                    & abs(angularFactor(currentlmIndex( &
!                                    & orbitalCount,2)))
!                           endif
!                           if (doRhoFIELD == 1) then
!                              atomicOrbitalRhoGamma(orbitalCount,n) = sum( &
!                                    & modifiedBasisFnsRhoGamma( &
!                                    & 1:tempNumAlphas,orbitalCount,n) * &
!                                    & expAlphaDist(1:tempNumAlphas)) * &
!                                    & abs(angularFactor(currentlmIndex( &
!                                    & orbitalCount,2)))
!                           endif
!#endif
!                        enddo ! n   spin
!                     enddo ! m   numKPoints
!
!!write (20,*) "j oC aO(oC)",j,orbitalCount,&
!!& atomicOrbital(orbitalCount,1)
!!write (20,*) "currlmI aF(currlmI)",&
!!& currentlmIndex(orbitalCount,2),&
!!& angularFactor(currentlmIndex(orbitalCount,2))
!!call flush (20)
!                  enddo ! l   Num of QN_m for this QN_l
!               enddo ! k   numValeRadialWaveFns
            endif ! Psi, Wav, Rho only.

            ! Accumulate the contribution of this replicated atom's orbitals
            !  onto the current mesh point.
#ifndef GAMMA
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
               do k = 1, numKPoints
                  do l = 1, spin+2
                     waveFnEvalPsiWav(l,k) = waveFnEvalPsiWav(l,k) + &
                           & sum(atomicOrbitalPsiWav(1:orbitalCount,l,k)) * &
                           & phaseFactor(k,j)
                  enddo
               enddo
            endif
            if (doRhoFIELD == 1) then
               do k = 1, numKPoints
                  do l = 1, spin+2
                     do m = 1, numStates
                        waveFnEvalRho(m,l,k) = waveFnEvalRho(m,l,k) + &
                              & sum(atomicOrbitalRho(1:orbitalCount,m,l,k)) * &
                              & phaseFactor(k,j)
                     enddo
                  enddo
               enddo
            endif
!if (j==2) then
!write (20,*) "wFE11,wFE21=",waveFnEval(1,1),waveFnEval(2,1)
!endif
#else
            if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
               do k = 1, spin+2
                  waveFnEvalPsiWavGamma(k) = waveFnEvalPsiWavGamma(k) + &
                        & sum(atomicOrbitalPsiWavGamma(1:orbitalCount,k))
               enddo
            endif
            if (doRhoFIELD == 1) then
               do k = 1, spin+2
                  do l = minStateIndex(1,1), maxStateIndex(1,1)
! The problem is that this does not account for cross terms between different
!   atoms that contribute to the charge density. For single isolated atoms
!   this doesn't make a big problem because the occupied orbitals are all
!   orthogonal and thus have no cross terms.
!                     waveFnEvalRhoGamma(l,k) = waveFnEvalRhoGamma(l,k) + &
!                           & sum(atomicOrbitalRhoGamma(1:orbitalCount,l,k))

                     waveFnEvalRhoGamma(currentValeStateIndex+1:&
                           & currentValeStateIndex+orbitalCount,l,k) = &
                           & waveFnEvalRhoGamma(currentValeStateIndex+1:&
                           & currentValeStateIndex+orbitalCount,l,k) + &
                           & atomicOrbitalRhoGamma(1:orbitalCount,l,k)
                  enddo
               enddo
            endif
#endif

            ! Accumulate the contribution of this replicated potential site's
            !   Gaussian set for the current mesh point.
            if (doPotFIELD == 1) then
               do k = 1, spin+2
                  dataChunkPot(k,a,b,c) = dataChunkPot(k,a,b,c) + &
                        & sum(currentPotCoeffs(1:lastContribPotAlphaIndex,k) * &
                        & expPotAlphaDist(1:lastContribPotAlphaIndex))
               enddo
            endif

         enddo ! j=numCellsReal
!write (20,*) "Did j-1 cells, j-1=",j-1
      enddo ! i=numAtomSites

!write (20,*) "waveFnEval",waveFnEval(:)

      ! Obtain the square of the evaluated function.
#ifndef GAMMA
!write (20,*) "waveFnEval(:,1)=",waveFnEval(:,1)
!write (20,*) "currNumElec(:,1)=",currNumElec(:,1)

      if (doPsiFIELD == 1) then
         if (spin == 1) then
            ! For the spin degenerate state, sum the psi-wav evaluation over
            !   the set of kpoints and store the real and imaginary psi.
            tempTerm(1) = sum(waveFnEvalPsiWav(1,:))
            dataChunkPsiReal(1,a,b,c) = real(tempTerm(1),double)
            dataChunkPsiImag(1,a,b,c) = aimag(tempTerm(1))

            ! For the spin degenerate state of the neutral, non-interacting
            !   system, sum the psi-wav evaluation over the set of kpoints.
            ! Store the interacting minus the non-interacting real and
            !   imaginary parts.
            tempTerm(2) = sum(waveFnEvalPsiWav(2,:))
            dataChunkPsiReal(2,a,b,c) = real(tempTerm(1),double) -  &
                  & real(tempTerm(2),double)
            dataChunkPsiImag(2,a,b,c) = aimag(tempTerm(1)) - &
                  & aimag(tempTerm(2))
         else
            do i = 1,spin
               ! For each spin state, sum the psi-wav evaluation over the set
               !   of kpoints and store the
               tempTerm(i) = sum(waveFnEvalPsiWav(i,:))
               dataChunkPsiReal(i,a,b,c) = real(tempTerm(i),double)
               dataChunkPsiImag(i,a,b,c) = aimag(tempTerm(i))
            enddo
         endif
      endif
      if (doWavFIELD == 1) then
         if (spin == 1) then
            dataChunkWav(1,a,b,c) = sum(conjg( &
                  & waveFnEvalPsiWav(1,:)) * waveFnEvalPsiWav(1,:))
         else
            do i = 1,spin
               tempTerm(i) = sum(conjg( &
                     & waveFnEvalPsiWav(i,:)) * waveFnEvalPsiWav(i,:))
            enddo
            dataChunkWav(1,a,b,c) = tempTerm(1) + tempTerm(2)
            dataChunkWav(2,a,b,c) = tempTerm(1) - tempTerm(2)
         endif
      endif
      if (doRhoFIELD == 1) then
         if (spin == 1) then
            do i = 1, numKPoints
               do j = 1, numStates
                  dataChunkRho(1,a,b,c) = dataChunkRho(1,a,b,c) + &
                        & conjg(waveFnEvalRho(j,1,i)) * waveFnEvalRho(j,1,i)
               enddo
            enddo
!            do i = 1, numStates
!               dataChunkRho(1,a,b,c) = dataChunkRho(1,a,b,c) + sum(conjg( &
!                     & waveFnEvalRho(i,1,:)) * waveFnEvalRho(i,1,:))
!            enddo
         else
            tempTerm(:) = 0.0_double
            do i = 1, numKPoints
               do j = 1, spin
                  do k = 1, numStates
                     tempTerm(j) = tempTerm(j) + &
                           & conjg(waveFnEvalRho(k,j,i)) * waveFnEvalRho(k,j,i)
                  enddo
               enddo
            enddo
 !           do i = 1,spin
 !              tempTerm(i) = 0.0_double
 !              do j = 1, numStates
 !                 tempTerm(i) = tempTerm(i) + sum(conjg( &
 !                       & waveFnEvalRho(j,i,:)) * waveFnEvalRho(j,i,:))
 !              enddo
 !           enddo
            dataChunkRho(1,a,b,c) = tempTerm(1) + tempTerm(2)
            dataChunkRho(2,a,b,c) = tempTerm(1) - tempTerm(2)
         endif
      endif

!      if (spin == 1) then
!         waveFnEval(:,1) = conjg(waveFnEval(:,1)) * waveFnEval(:,1)
!         dataChunk(1,a,b,c) = sum(waveFnEval(:,1) * currNumElec(:,1))
!         waveFnEval(:,2) = conjg(waveFnEval(:,2)) * waveFnEval(:,2)
!         dataChunk(2,a,b,c) = sum(waveFnEval(:,2) * &
!               & 0.5_double * kPointWeight(:))
!      else
!         waveFnEval(:,1) = conjg(waveFnEval(:,1)) * waveFnEval(:,1)
!         dataChunk(1,a,b,c) = sum(waveFnEval(:,1) * currNumElec(:,1))
!         waveFnEval(:,2) = conjg(waveFnEval(:,2)) * waveFnEval(:,2)
!         dataChunk(2,a,b,c) = sum(waveFnEval(:,2) * currNumElec(:,2))
!         waveFnEval(:,3) = conjg(waveFnEval(:,3)) * waveFnEval(:,3)
!         dataChunk(3,a,b,c) = sum(waveFnEval(:,3) * &
!               & numElectrons * 0.5_double * kPointWeight(:))
!
!         ! Compute the total charge as the sum of the up and down.
!         dataChunk(1,a,b,c) = dataChunk(1,a,b,c) + dataChunk(2,a,b,c)
!
!         ! Compute the spin difference charge as the difference between the
!         !   up and down.  Note that this computation *must* be done *after*
!         !   the computation of the total charge.
!         dataChunk(2,a,b,c) = dataChunk(1,a,b,c) - &
!               & 2.0_double * dataChunk(2,a,b,c)
!      endif

!      ! Compute (the charge density for this point) - (the charge density for
!      !   this point assuming non-interacting neutral atoms).
!      dataChunk(spin+1,a,b,c) = dataChunk(1,a,b,c) - &
!            & dataChunk(spin+1,a,b,c)

!write (20,*) "waveFnEval(:,1)=",waveFnEval(:,1)
!write (20,*) "cPV(1)=",dataChunk(1,a,b,c)

#else
      if (doPsiFIELD == 1) then
         if (spin == 1) then
            dataChunkPsiReal(1,a,b,c) = waveFnEvalPsiWavGamma(1)
         else
            dataChunkPsiReal(1,a,b,c) = waveFnEvalPsiWavGamma(1) + &
                  & waveFnEvalPsiWavGamma(2) ! Total up+dn
            dataChunkPsiReal(2,a,b,c) = waveFnEvalPsiWavGamma(1) - &
                  & waveFnEvalPsiWavGamma(2) ! Diff up-dn
         endif
      endif
      if (doWavFIELD == 1) then
         if (spin == 1) then
            dataChunkWav(1,a,b,c) = waveFnEvalPsiWavGamma(1) * &
                  & waveFnEvalPsiWavGamma(1)
         else
            tempTerm(:) = waveFnEvalPsiWavGamma(:)**2
            dataChunkWav(1,a,b,c) = tempTerm(1) + tempTerm(2)
            dataChunkWav(2,a,b,c) = tempTerm(1) - tempTerm(2)
         endif
      endif
      if (doRhoFIELD == 1) then
         if (spin == 1) then
            do i = minStateIndex(1,1), maxStateIndex(1,1)
!               dataChunkRho(1,a,b,c) = dataChunkRho(1,a,b,c) + &
!                     & waveFnEvalRhoGamma(i,1) * waveFnEvalRhoGamma(i,1)
!write(20,*) waveFnEvalRhoGamma(:,i,1)
               do j = 1, valeDim
                  do k = j, valeDim
                     dataChunkRho(1,a,b,c) = dataChunkRho(1,a,b,c) + &
                           & waveFnEvalRhoGamma(k,i,1) * waveFnEvalRhoGamma(j,i,1)
                  enddo
               enddo
            enddo
         else
            do i = 1, numStates
!               tempTerm(:) = waveFnEvalRhoGamma(i,:)**2
!               dataChunkRho(1,a,b,c) = dataChunkRho(1,a,b,c) + &
!                     & tempTerm(1) + tempTerm(2)
!               dataChunkRho(2,a,b,c) = dataChunkRho(2,a,b,c) + &
!                     & tempTerm(1) - tempTerm(2)
            enddo
         endif
      endif
#endif

      ! Accumulate the data for the profiles.
      if (doProfileField == 1) then
         if (doPsiFIELD == 1) then
            call accumulateProfile(profilePsiReal,dataChunkPsiReal,a,b,c)
#ifndef GAMMA
            call accumulateProfile(profilePsiImag,dataChunkPsiImag,a,b,c)
#endif
         endif
         if (doWavFIELD == 1) then
            call accumulateProfile(profileWav,dataChunkWav,a,b,c)
         endif
         if (doRhoFIELD == 1) then
            call accumulateProfile(profileRho,dataChunkRho,a,b,c)
         endif
         if (doPotFIELD == 1) then
            call accumulateProfile(profilePot,dataChunkPot,a,b,c)
         endif
      endif

      if ((doXDMFField == 1) .and. (triggerAxis == 1) .and. &
            & (a == numMeshPoints(1))) then

         ! Select the hyperslab to write to for all data sets.
         call h5sselect_hyperslab_f (field_dsid,H5S_SELECT_SET_F,&
               & currentStartIndices,fieldDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select field hyperslab chunk. a'

         ! Now, record the data.
         if (doPsiFIELD == 1) then
            call writeFieldHDF5(psiR_did(1),1,dataChunkPsiReal,"psiR_did(1)",&
                  & "a")
#ifndef GAMMA
            call writeFieldHDF5(psiI_did(1),1,dataChunkPsiImag,"psiI_did(1)",&
                  & "a")
#endif
            if (spin == 2) then
               call writeFieldHDF5(psiR_did(2),2,dataChunkPsiReal,&
                     & "psiR_did(2)","a")
#ifndef GAMMA
               call writeFieldHDF5(psiI_did(2),2,dataChunkPsiImag,&
                     & "psiI_did(2)","a")
#endif
            endif
         endif
         if (doWavFIELD == 1) then
            call writeFieldHDF5(wav_did(1),1,dataChunkWav,"wav_did(1) ","a")
            if (spin == 2) then
               call writeFieldHDF5(wav_did(2),2,dataChunkWav,"wav_did(2) ","a")
            endif
         endif
         if (doRhoFIELD == 1) then
            call writeFieldHDF5(rho_did(1),1,dataChunkRho,"rho_did(1) ","a")
            if (spin == 2) then
               call writeFieldHDF5(rho_did(2),2,dataChunkRho,"rho_did(2) ","a")
            endif
         endif
         if (doPotFIELD == 1) then
            call writeFieldHDF5(pot_did(1),1,dataChunkPot,"pot_did(1) ","a")
            if (spin == 2) then
               call writeFieldHDF5(pot_did(2),2,dataChunkPot,"pot_did(2) ","a")
            endif
         endif

         ! Shift the initial points of the hyperslab.
         currentStartIndices(1) = 0
         if (b == numMeshPoints(2)) then
            currentStartIndices(2) = 0
            currentStartIndices(3) = c+1
         else
            currentStartIndices(2) = b+1
            currentStartIndices(3) = c ! Technically not necessary. Already set
         endif
      endif

   enddo ! a-axis loop

      if ((doXDMFField == 1) .and. (triggerAxis == 2) .and. &
            & (b == numMeshPoints(2))) then

         ! Select the hyperslab to write to for all data sets.
         call h5sselect_hyperslab_f (field_dsid,H5S_SELECT_SET_F,&
               & currentStartIndices,fieldDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select field hyperslab chunk b'

         ! Now, record the data.
         if (doPsiFIELD == 1) then
            call writeFieldHDF5(psiR_did(1),1,dataChunkPsiReal,&
                  & "psiR_did(1)","b")
#ifndef GAMMA
            call writeFieldHDF5(psiI_did(1),1,dataChunkPsiImag,&
                  & "psiI_did(1)","b")
#endif
            if (spin == 2) then
               call writeFieldHDF5(psiR_did(2),2,dataChunkPsiReal,&
                     & "psiR_did(2)","b")
#ifndef GAMMA
               call writeFieldHDF5(psiI_did(2),2,dataChunkPsiImag,&
                     & "psiI_did(2)","b")
#endif
            endif
         endif
         if (doWavFIELD == 1) then
            call writeFieldHDF5(wav_did(1),1,dataChunkWav,"wav_did(1) ","b")
            if (spin == 2) then
               call writeFieldHDF5(wav_did(2),2,dataChunkWav,"wav_did(2) ","b")
            endif
         endif
         if (doRhoFIELD == 1) then
            call writeFieldHDF5(rho_did(1),1,dataChunkRho,"rho_did(1) ","b")
            if (spin == 2) then
               call writeFieldHDF5(rho_did(2),2,dataChunkRho,"rho_did(2) ","b")
            endif
         endif
         if (doPotFIELD == 1) then
            call writeFieldHDF5(pot_did(1),1,dataChunkPot,"pot_did(1) ","b")
            if (spin == 2) then
               call writeFieldHDF5(pot_did(2),2,dataChunkPot,"pot_did(2) ","b")
            endif
         endif

         ! Shift the initial points of the hyperslab.
         currentStartIndices(1) = 0
         currentStartIndices(2) = 0
         currentStartIndices(3) = c+1
      endif

   enddo ! b-axis loop

      ! Store the current chunks on disk as HDF5 data if necessary.
      if ((doXDMFField == 1) .and. (triggerAxis == 3) .and. &
            & (c == numMeshPoints(3))) then

         ! Select the hyperslab to write to for all data sets.
         call h5sselect_hyperslab_f (field_dsid,H5S_SELECT_SET_F,&
               & currentStartIndices,fieldDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select field hyperslab chunk c'

         ! Now, record the data.
         if (doPsiFIELD == 1) then
            call writeFieldHDF5(psiR_did(1),1,dataChunkPsiReal,&
                  & "psiR_did(1)","c")
#ifndef GAMMA
            call writeFieldHDF5(psiI_did(1),1,dataChunkPsiImag,&
                  & "psiI_did(1)","c")
#endif
            if (spin == 2) then
               call writeFieldHDF5(psiR_did(2),2,dataChunkPsiReal,&
                     & "psiR_did(2)","c")
#ifndef GAMMA
               call writeFieldHDF5(psiI_did(2),2,dataChunkPsiImag,&
                     & "psiI_did(2)","c")
#endif
            endif
         endif
         if (doWavFIELD == 1) then
            call writeFieldHDF5(wav_did(1),1,dataChunkWav,"wav_did(1) ","c")
            if (spin == 2) then
               call writeFieldHDF5(wav_did(2),2,dataChunkWav,"wav_did(2) ","c")
            endif
         endif
         if (doRhoFIELD == 1) then
            call writeFieldHDF5(rho_did(1),1,dataChunkRho,"rho_did(1) ","c")
            if (spin == 2) then
               call writeFieldHDF5(rho_did(2),2,dataChunkRho,"rho_did(2) ","c")
            endif
         endif
         if (doPotFIELD == 1) then
            call writeFieldHDF5(pot_did(1),1,dataChunkPot,"pot_did(1) ","c")
            if (spin == 2) then
               call writeFieldHDF5(pot_did(2),2,dataChunkPot,"pot_did(2) ","c")
            endif
         endif
if (doRhoFIELD == 1) then
write (20,*) "rho=",sum(dataChunkRho(1,:,:,:)) * realCellVolume / &
      & (product(numMeshPoints(:)))
endif
      endif

      ! Record that this loop has finished.
      if (mod(c,10) .eq. 0) then
         write (20,ADVANCE="NO",FMT="(a1)") "|"
      else
         write (20,ADVANCE="NO",FMT="(a1)") "."
      endif
      if (mod(c,50) .eq. 0) then
         write (20,*) " ",c
      endif
      call flush (20)

   enddo ! c-axis loop

   ! Finalize printing of the OpenDX field data.
!   if (doODXField == 1) then
!
!      ! Write a newline to finish out any uneven (incomplete) lines if needed.
!      if (mod(currentPointCount,5) /= 0) then
!         do i = 1,numCols
!            write (57+i,*)
!         enddo
!      endif
!
!      ! Print the tail for the field data.
!      call printODXFieldTail (numCols)
!   endif


   ! Print the profile data.
   if (doProfileField == 1) then
      call printProfileData
   endif


   ! Deallocate unnecessary arrays and matrices.
   deallocate (minStateIndex)
   deallocate (maxStateIndex)
   deallocate (structuredElectronPopulation)
   deallocate (currentBasisFns)
   deallocate (currentAlphas)
   deallocate (currentlmAlphaIndex)
   deallocate (currentlmIndex)
   deallocate (currentValeQN_lList)
   deallocate (accumCharge)
   if (doPsiFIELD == 1) then
      deallocate (dataChunkPsiReal)
      deallocate (profilePsiReal)
#ifndef GAMMA
      deallocate (dataChunkPsiImag)
      deallocate (profilePsiImag)
#endif
   endif
   if (doWavFIELD == 1) then
      deallocate (dataChunkWav)
      deallocate (profileWav)
   endif
   if (doRhoFIELD == 1) then
      deallocate (dataChunkRho)
      deallocate (profileRho)
   endif
   if (doPotFIELD == 1) then
      deallocate (dataChunkPot)
      deallocate (profilePot)
   endif
#ifndef GAMMA
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      deallocate (waveFnEvalPsiWav)
      deallocate (atomicOrbitalPsiWav)
      deallocate (modifiedBasisFnsPsiWav)
      deallocate (accumWaveFnCoeffsPsiWav)
   endif
   if (doRhoFIELD == 1) then
      deallocate (waveFnEvalRho)
      deallocate (atomicOrbitalRho)
      deallocate (modifiedBasisFnsRho)
      deallocate (accumWaveFnCoeffsRho)
   endif
!   deallocate (tempRealValeVale)
!   deallocate (tempImagValeVale)
#else
   if ((doPsiFIELD == 1) .or. (doWavFIELD == 1)) then
      deallocate (waveFnEvalPsiWavGamma)
      deallocate (atomicOrbitalPsiWavGamma)
      deallocate (modifiedBasisFnsPsiWavGamma)
      deallocate (accumWaveFnCoeffsPsiWavGamma)
   endif
   if (doRhoFIELD == 1) then
      deallocate (waveFnEvalRhoGamma)
      deallocate (atomicOrbitalRhoGamma)
      deallocate (modifiedBasisFnsRhoGamma)
      deallocate (accumWaveFnCoeffsRhoGamma)
   endif
#endif

   allocate (meshChunk(3,meshDimsChunk(2),meshDimsChunk(3),&
         & meshDimsChunk(4)))

   ! Define the initial points of the hyperslab if XDMF HDF5 output is needed.
   if (doXDMFField == 1) then
      currentMeshStartIndices(:) = 0
   endif

   ! Create and then record the mesh specification.
   do c = 1, numMeshPoints(3)
      cStepSize = real(c-1,double)/real(numMeshPoints(3),double)
   do b = 1, numMeshPoints(2)
      bStepSize = real(b-1,double)/real(numMeshPoints(2),double)
   do a = 1, numMeshPoints(1)
      aStepSize = real(a-1,double)/real(numMeshPoints(1),double)
      do l = 1,3
         meshChunk(l,a,b,c) = realVectors(l,1)*aStepSize + &
               & realVectors(l,2)*bStepSize + realVectors(l,3)*cStepSize
      enddo

      if ((doXDMFField == 1) .and. (meshTriggerAxis == 1) .and. &
            & (a == numMeshPoints(1))) then

         ! Select the hyperslab to write to for the mesh.
         call h5sselect_hyperslab_f (mesh_dsid,H5S_SELECT_SET_F,&
               & currentMeshStartIndices,meshDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select mesh h-slab chunk a'

         ! Now, record the data.
         call h5dwrite_f (mesh_did,H5T_NATIVE_DOUBLE,meshChunk(:,:,:,:),&
               & meshDimsChunk,hdferr,memMeshChunk_dsid,mesh_dsid)
         if (hdferr /= 0) stop 'Failed to write mesh_did chunk a'


         ! Shift the initial points of the hyperslab.
         currentMeshStartIndices(2) = 0
         if (b == numMeshPoints(2)) then
            currentMeshStartIndices(3) = 0
            currentMeshStartIndices(4) = c+1
         else
            currentMeshStartIndices(3) = b+1
            currentMeshStartIndices(4) = c
         endif
      endif
   enddo ! a-axis loop

      if ((doXDMFField == 1) .and. (meshTriggerAxis == 2) .and. &
            & (b == numMeshPoints(2))) then

         ! Select the hyperslab to write to for the mesh.
         call h5sselect_hyperslab_f (mesh_dsid,H5S_SELECT_SET_F,&
               & currentMeshStartIndices,meshDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select hyperslab for mesh b'

         ! Now, record the data.
         call h5dwrite_f (mesh_did,H5T_NATIVE_DOUBLE,meshChunk(:,:,:,:),&
               & meshDimsChunk,hdferr,memMeshChunk_dsid,mesh_dsid)
         if (hdferr /= 0) stop 'Failed to write mesh_did chunk b'

         ! Shift the initial points of the hyperslab.
         currentMeshStartIndices(2) = 0
         currentMeshStartIndices(3) = 0
         currentMeshStartIndices(4) = c+1
      endif
   enddo ! b-axis loop

      ! Store the current chunks on disk as HDF5 data if necessary.
      if ((doXDMFField == 1) .and. (meshTriggerAxis == 3) .and. &
            & (c == numMeshPoints(3))) then
!write (6,*) "cMSI: ", currentMeshStartIndices(:)
!write (6,*) "mDC: ", meshDimsChunk(:)

         ! Select the hyperslab to write to for the mesh.
         call h5sselect_hyperslab_f (mesh_dsid,H5S_SELECT_SET_F,&
               & currentMeshStartIndices,meshDimsChunk,hdferr)
         if (hdferr /= 0) stop 'Failed to select hyperslab for mesh c'

         ! Now, record the data.
         call h5dwrite_f (mesh_did,H5T_NATIVE_DOUBLE,meshChunk(:,:,:,:),&
               & meshDimsChunk,hdferr,memMeshChunk_dsid,mesh_dsid)
         if (hdferr /= 0) stop 'Failed to write mesh_did chunk c'
      endif
   enddo ! c-axis loop

   deallocate (meshChunk)

   ! Log the end of the wave function evaluation.
   call timeStampEnd(25)

end subroutine computeFieldMesh


! This subroutine will set some default (hard coded) values for some array
!   sizes and other values.  (Basically, this will just be an easy place to
!   change values if the program is modified or extended in the future.)
subroutine initEnv

   ! Use necessary modules
   use O_Potential, only: spin
   use O_Input, only: doProfileField, doPsiFIELD, doWavFIELD, doRhoFIELD, &
         & doPotFIELD, doXDMFField

   ! Make sure that no variables are accidentally defined.
   implicit none

end subroutine initEnv


subroutine printProfileData

   ! Use necessary modules
   use O_Kinds
   use O_Potential, only: spin
   use O_Constants, only: hartree, bohrRad
   use O_Lattice,   only: realMag, realFractCrossArea, realFractStrideLength, &
         & realPlaneAngles, numMeshPoints
   use O_FieldHDF5, only: dataSetNames
   use O_Input, only: doPsiFIELD, doWavFIELD, doRhoFIELD, doPotFIELD

   ! Make sure that no variables are accidentally defined.
   implicit none

   ! Declare local variables.
   integer :: i,j
!   real (kind=double), dimension(numCols) :: integral
   character*1, dimension(3) :: axis

   axis(1) = "a"
   axis(2) = "b"
   axis(3) = "c"

   ! Open the profile data files.
   open (unit=30,file='fort.30',form='formatted')
   open (unit=31,file='fort.31',form='formatted')
   open (unit=32,file='fort.32',form='formatted')

   ! Print the header.
   do i = 1,3
      write(29+i,fmt="(a1,a3)",advance="NO") axis(i),"Pos"
      if (doPsiFIELD == 1) then
         write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(1)
#ifndef GAMMA
         write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(5)
#endif
         if (spin == 2) then
            write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(2)
#ifndef GAMMA
            write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(6)
#endif
         endif
      endif
      if (doWavFIELD == 1) then
         write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(9)
         if (spin == 2) then
            write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(10)
         endif
      endif
      if (doRhoFIELD == 1) then
         write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(13)
         if (spin == 2) then
            write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(14)
         endif
      endif
      if (doPotFIELD == 1) then
         write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(17)
         if (spin == 2) then
            write(29+i,fmt="(a1,a)",advance="NO") " ",dataSetNames(18)
         endif
      endif
      write (29+i,*)
   enddo
!   write (30,fmt="(6a13)") "aPos",colLabel(:)
!   write (31,fmt="(6a13)") "bPos",colLabel(:)
!   write (32,fmt="(6a13)") "cPos",colLabel(:)

   ! Adjust the charge profiles to average out the cross sectional area effect
   !   and the fact that the profiles are simple accumulations of the other
   !   axes.  For the case of the potential we multiply by hartree to get the
   !   results in the correct units of energy.
   do i = 1, 3
!write (20,*) "i,realFractCrossArea(i)=",i,realFractCrossArea(i)
!write (20,*) "i,realFractStrideLength(i)=",i,realFractStrideLength(i)
!call flush (20)
      if (doPsiFIELD == 1) then
         profilePsiReal(i,1:spin,1:numMeshPoints(i)) = &
               & profilePsiReal(i,1:spin,1:numMeshPoints(i)) * &
               & realFractCrossArea(i)
#ifndef GAMMA
         profilePsiImag(i,1:spin,1:numMeshPoints(i)) = &
               & profilePsiImag(i,1:spin,1:numMeshPoints(i)) * &
               & realFractCrossArea(i)
#endif
      endif
      if (doWavFIELD == 1) then
         profileWav(i,1:spin,1:numMeshPoints(i)) = &
               & profileWav(i,1:spin,1:numMeshPoints(i)) * &
               & realFractCrossArea(i)
      endif
      if (doRhoFIELD == 1) then
         profileRho(i,1:spin,1:numMeshPoints(i)) = &
               & profileRho(i,1:spin,1:numMeshPoints(i)) * &
               & realFractCrossArea(i)
      endif
      if (doPotFIELD == 1) then
         profilePot(i,1:spin,1:numMeshPoints(i)) = &
               & profilePot(i,1:spin,1:numMeshPoints(i)) * hartree * &
               & realFractCrossArea(i)
      endif
   enddo

   ! Print the profiles.
   do i = 1,3
!write (20,*) "i,realMag(i)=",i,realMag(i)
!call flush (20)
      do j = 1, numMeshPoints(i)
         write (29+i,fmt="(e13.4)",advance="NO") (j-1) * &
               & realFractStrideLength(i) * realMag(i) * bohrRad
         if (doPsiFIELD == 1) then
            write (29+i,fmt="(x,e13.4)",advance="NO") profilePsiReal(i,1,j)
#ifndef GAMMA
            write (29+i,fmt="(x,e13.4)",advance="NO") profilePsiImag(i,1,j)
#endif
            if (spin == 2) then
               write (29+i,fmt="(x,e13.4)",advance="NO") profilePsiReal(i,2,j)
#ifndef GAMMA
               write (29+i,fmt="(x,e13.4)",advance="NO") profilePsiImag(i,2,j)
#endif
            endif
         endif
         if (doWavFIELD == 1) then
            write (29+i,fmt="(x,e13.4)",advance="NO") profileWav(i,1,j)
            if (spin == 2) then
               write (29+i,fmt="(x,e13.4)",advance="NO") profileWav(i,2,j)
            endif
         endif
         if (doRhoFIELD == 1) then
            write (29+i,fmt="(x,e13.4)",advance="NO") profileRho(i,1,j)
            if (spin == 2) then
               write (29+i,fmt="(x,e13.4)",advance="NO") profileRho(i,2,j)
            endif
         endif
         if (doPotFIELD == 1) then
            write (29+i,fmt="(x,e13.4)",advance="NO") profilePot(i,1,j)
            if (spin == 2) then
               write (29+i,fmt="(x,e13.4)",advance="NO") profilePot(i,2,j)
            endif
         endif
         write (29+i,*)
!         write (29+i,fmt="(6e13.4)") (j-1) * realFractStrideLength(i) * &
!               & realMag(i) * bohrRad, profile(i,1:numCols-spin,j) / bohrRad,&
!               & profile(i,numCols-spin+1:numCols,j)
      enddo
   enddo

   ! Close the profile data files.
   close (30)
   close (31)
   close (32)

   ! Integrate the charge and print the result to the primary output file.  For
   !   the case of the potential we simply obtain the average along each axis.
!   do i = 1, 3
!!write (20,*) "fSL(:)=",realFractStrideLength(:)
!!write (20,*) "lM(:)=",realMag(:)
!!write (20,*) "s(pA(:))=",sin(realPlaneAngles(:))
!!call flush (20)
!      integral(:) = 0.0_double
!
!      ! Accumulate across all mesh points.
!      do j = 1, numMeshPoints(i)
!         integral(1:numCols-spin) = integral(1:numCols-spin) + &
!               & profile(i,1:numCols-spin,j)
!         integral(numCols-spin+1:numCols) = integral(numCols-spin+1:numCols) + &
!               & profile(i,numCols-spin+1:numCols,j)
!      enddo
!
!      ! Factor in the spacing for charge, and average the potential.
!      integral(1:numCols-spin) = integral(1:numCols-spin) * &
!            & realFractStrideLength(i) * realMag(i) * sin(realPlaneAngles(i))
!      integral(numCols-spin+1:numCols) = integral(numCols-spin+1:numCols) / &
!            numMeshPoints(i)
!
!      ! Print the results.
!      write (20,fmt="(6a13)") colLabel(:),"Integrated"
!      write (20,fmt="(5e13.4)") integral(:)
!   enddo

end subroutine printProfileData


subroutine makeNeutralCoeffs

   ! Import any necessary modules.
   use O_Kinds
   use O_Constants,   only: lAngMomCount
   use O_ElementData, only: coreCharge, valeCharge
   use O_KPoints,     only: numKPoints, kPointWeight
   use O_AtomicSites, only: valeDim, numAtomSites, atomSites
   use O_AtomicTypes, only: atomTypes
   use O_PotTypes,    only: potTypes
   use O_Potential,   only: spin

   ! Make sure no implicit variables are created.
   implicit none

   ! Define local variables.
   integer :: i,j,k
   integer :: currAtomType
   integer :: currQN_l
   integer :: totalStateCount
   real (kind=double) :: electronsPerQN_m
   real (kind=double), dimension(lAngMomCount) :: localValeCharge
   real (kind=double), allocatable, dimension(:) :: neutralCoeffs

   ! Allocate temp space to hold the neutral coefficients before copying them
   !   to the (possibly complex values) waveFnCoeffs.
   allocate (neutralCoeffs(valeDim))

   ! Initialize the count of the number of states in the system.  This will
   !   reach to valeDim at the end.
   totalStateCount = 0

   ! For each orbital of each atom we need to provide an electron occupation
   !   number that represents the distribution of electrons in a neutral non-
   !   interacting atom.  This is a crude approximation and not at all as
   !   rigorous as it should be.  I suppose that in the future this could be
   !   improved.
   ! Recall that each orbital is spin degenerate in the approximation to the
   !   neutral atom that we are using.
   do i = 1, numAtomSites

      ! Get the current atom type.
      currAtomType = atomSites(i)%atomTypeAssn

      ! Get a copy of the number of valence electrons in each s,p,d,f type
      !   atomic orbitals (in the neutral condition).  (We identify the index
      !   number by looking at the Z value of this atomic site's nuclear
      !   potential.  Yeah, I know...indirect.)
      localValeCharge(:) = valeCharge(:,int(potTypes(currAtomType)%nucCharge))

      ! In the case where this atom has no core radial basis functions we can
      !   deduce two possible reasons.  (1)  This atom actually never will have
      !   any core basis functions and all it's electrons are always considered
      !   to be in the valence (e.g. H and He).  (2)  This atom is a target
      !   atom in a XANES/ELNES calculation and it typically does have some
      !   number of core radial basis functions.
      ! For case #2 we must add the coreCharge from the database to the
      !   valeCharge from the database to make sure that we count all the
      !   electrons and populate all the atomic orbital basis functions
      !   properly.
      ! If there are zero core radial functions we can simply add the core
      !   charge to the valence charge to solve the problem with case #2, and
      !   this will not affect case #1 because the core charge values there are
      !   always zero.
      if (atomTypes(currAtomType)%numCoreRadialFns == 0) then
         localValeCharge(:) = localValeCharge(:) + &
               & coreCharge(:,int(potTypes(currAtomType)%nucCharge))
      endif
!write (20,*) "localVC=",localValeCharge(:)
!write (20,*) "numValeRadFns=",atomTypes(currAtomType)%numValeRadialFns

      do j = 1, atomTypes(currAtomType)%numValeRadialFns

         ! Get the current orbital type (l quantum number)
         currQN_l = atomTypes(currAtomType)%valeQN_lList(j)
!write (20,*) "j,currQN_l",j,currQN_l

         ! Determine the number of electrons to be evenly spread in all QN_m
         !   orbitals of this QN_l from the remaining available electrons for
         !   this QN_l.

         ! First check if there are any electrons left for these orbitals.  If
         !   not, then we will have 0 electrons per QN_m orbital.  If there are
         !   some then we must determine if it is enough to fill the orbital or
         !   if it will only partially fill it.  In either case we will
         !   subtract the electrons that are about to be spread from the local
         !   valence charge list of all electrons.
         ! Note that the +1 is because the currQN_l starts at 0 but arrays are
         !   indexed starting from 1.  This will be applied many times in the
         !   following sections.  Watch out because we must also compute
         !   2*QN_l+1 which has a different meaning.  (Number of QN_m for this
         !   QN_l.)
         if (localValeCharge(currQN_l+1) >= 0) then

            ! We have some electrons to spread for this spdf orbital type.

            ! Check if we can fill this QN_l orbital.  (2 electrons per QN_m)
            if (localValeCharge(currQN_l+1) - 2*(2*currQN_l+1) >= 0) then

               ! Every QN_m gets 2 electrons.
               electronsPerQN_m = 2.0_double
!write (20,*) "if elecPerQN_m=",electronsPerQN_m

               ! Remove 2 electrons from the available set for each QN_m.
               localValeCharge(currQN_l+1) = localValeCharge(currQN_l+1) - &
                     & 2.0_double * (2*currQN_l+1) ! -2 for s, -6 for p, ...
!write (20,*) "if localVC=",localValeCharge(:)
            else

               ! Every QN_m gets x / (# QN_m orbitals) where x is the number of
               !   electrons remaining for this QN_l.
               electronsPerQN_m = localValeCharge(currQN_l+1) / &
                     & real((2*currQN_l+1),double)
!write (20,*) "else elecPerQN_m=",electronsPerQN_m

               ! We have used up all the electrons for this QN_l.
               localValeCharge(currQN_l+1) = 0.0_double
!write (20,*) "else localVC=",localValeCharge(:)
            endif
         else
            ! There are no electrons to spread.  (Either they were used up, or
            !   there were none to begin with.)
            electronsPerQN_m = 0.0_double
         endif

         ! Spread the electrons evenly to all QN_m orbitals of this QN_l.
         do k = 1, 2 * currQN_l + 1

            ! Increment the state counter.
            totalStateCount = totalStateCount + 1

            neutralCoeffs(totalStateCount) = electronsPerQN_m
         enddo
      enddo
   enddo

!write (20,*) "neutCoeffs=",neutralCoeffs(:)

#ifndef GAMMA
   ! Save the neutral coefficients in index 2 or 3 depending on whether or not
   !   the calculation is spin non-polarized or spin polarized.  Note that the
   !   non-neutral coefficients must also be a unit vector for evaluation
   !   on the mesh and then later scaled by the charge that this kpoint
   !   represents. (Note sure about that last sentence. FIX)
   ! Note that at this point we cannot get the neutral charge over a specific
   !   energy range because we do not have the energy values for each of the
   !   neutral atom electron states available here.  That would require a
   !   separate calculation for a neutral atom.  All we have available here is
   !   the total charge over all occupied atomic states.
   do i = 1, numKPoints
      accumWaveFnCoeffsNeut(:,i) = &
         & sqrt(cmplx(neutralCoeffs(:),0.0_double) / 2.0_double * &
         & kPointWeight(i)/real(spin,double))
!         accumWaveFnCoeffsPsiWav(:,j+2,i) = &
!               & cmplx(neutralCoeffs(:),0.0_double) / &
!               & sqrt(dot_product(neutralCoeffs(:),neutralCoeffs(:)))
   enddo
#else
   accumWaveFnCoeffsNeutGamma(:) = sqrt(neutralCoeffs(:) / real(spin,double))
!      accumWaveFnCoeffsGamma(:,spin+1) = neutralCoeffs(:) / &
!            & sqrt(dot_product(neutralCoeffs(:),neutralCoeffs(:)))
#endif

   ! All done.
   deallocate (neutralCoeffs)

end subroutine makeNeutralCoeffs


subroutine accumulateProfile(profile,dataChunk,a,b,c)

   use O_Potential, only: spin

   implicit none

   ! Define passed parameters.
   real (kind=double), dimension (:,:,:), intent(inout) :: profile
   real (kind=double), dimension (:,:,:,:), intent(in) :: dataChunk
   integer, intent(in) :: a, b, c

   ! Define local variables
   integer :: i

   do i = 1,spin
      profile(1,i,a) = profile(1,i,a) + dataChunk(i,a,b,c)
      profile(2,i,b) = profile(2,i,b) + dataChunk(i,a,b,c)
      profile(3,i,c) = profile(3,i,c) + dataChunk(i,a,b,c)
   enddo

end subroutine accumulateProfile


subroutine writeFieldHDF5(did,idx,dataChunk,didName,axis)

   use HDF5
   use O_FieldHDF5, only: fieldDimsChunk, memFieldChunk_dsid, field_dsid

   implicit none

   ! Define passed parameters.
   integer(hid_t) :: did
   integer, intent(in) :: idx
   real(kind=double), dimension(:,:,:,:) :: dataChunk
   character*11, intent(in) :: didName
   character*1, intent(in) :: axis

   ! Define local variables.
   integer :: hdferr

   call h5dwrite_f (did,H5T_NATIVE_DOUBLE,dataChunk(idx,:,:,:),&
         & fieldDimsChunk,hdferr,memFieldChunk_dsid,field_dsid)
   if (hdferr /= 0) then
      write(*,fmt="(4a)") 'Failed to write ',trim(didName),' chunk ',axis
      stop
   endif

end subroutine writeFieldHDF5


subroutine cleanUpField

   ! Make sure that no variables are accidentally defined.
   implicit none

   ! Deallocate everything that was not previously deallocated.
!   deallocate (profile)

end subroutine cleanUpField

end module O_Field
